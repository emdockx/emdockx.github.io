x = ~date,
y = ~TRIMP,
color = ~type,
colors = colors,
name = ~type,
yaxis = "y2",
width = 86400000 * 1,
showlegend = TRUE,
customdata   = ~toupper(gsub(" TRIMP", "", type)),
hovertemplate = "<b>%{customdata}</b><br>%{x|%A}<br>%{x|%m/%d/%Y}<br>TRIMP: %{y}<extra></extra>") |>
# ATL line  ── black, width 2 ≈ size 1 in ggplot
add_lines(y = ~ATL/100,
name = "ATL (7-day)",
line = list(color = rgb(1, 1, 1, 0.50), width = 1, dash = "dot"),
hovertemplate = "<b>%{x|%A}<br>%{x|%m/%d/%Y}</b><br>ATL: %{y:.0%}<extra></extra>") |>
# CTL line  ── grey, width 2 ≈ size 1 in ggplot
add_lines(y = ~CTL/100,
name = "CTL (42-day)",
line = list(color = "#eb4034",  width = 4),
hovertemplate = "<b>%{x|%A}<br>%{x|%m/%d/%Y}</b><br>CTL: %{y:.0%}<extra></extra>") |>
# Hide details
config(displayModeBar = FALSE, staticPlot = FALSE) |>
# centre annotation
layout(
paper_bgcolor="#2d2d2d",
plot_bgcolor="#2d2d2d",
xaxis = list(zeroline = FALSE, fixedrange = TRUE, tickformat = "%b", tickvals = seq(as.Date("2025-01-01"), as.Date("2025-12-15"), by = "month"), ticktext = format(seq(as.Date("2025-01-01"), as.Date("2025-12-15"), by = "month"), "%b"), color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25),
yaxis  = list(zeroline = FALSE, fixedrange = TRUE, color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25, tickformat = ".0%"),
yaxis2 = list(zeroline = FALSE, fixedrange = TRUE, color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25, overlaying = "y", side = "right", range = c(0, 2 * max(trimp_daily$TRIMP, na.rm = TRUE))),
barmode = 'overlay',
legend = list(orientation = "v", x = 0.05, y = 1, font = list(color = "white")),
margin = list(l = 0, r = 30, t = 0, b = 0)
)
# Functie om training load meters te maken
gauge_full <- function(title,
value,
steps = 250,
palette = c("lightgreen", "yellow", "red", "darkred"),
hole   = 0.6,
font_size = 50,
background_color = rgb(0, 0, 0, 0.10)) {
# ---- basic sanity checks --------------------------------------------------
if (!is.numeric(value) || value < 0 || value > steps) {
stop("`value` must be between 0 and `steps` (", steps, ").", call. = FALSE)
}
# ---- build colour vectors -------------------------------------------------
full_palette  <- colorRampPalette(palette)(steps)        # complete gradient
fill_colors   <- full_palette[seq_len(value)]            # part to show
transparent   <- "rgba(0,0,0,0)"                         # invisible slices
fg_colors     <- c(fill_colors, rep(transparent, steps - value))
# one unit per slice so ∑ = 360°
values  <- rep(1, steps)
labels  <- paste0("slice_", seq_len(steps))              # invisible
# ---- assemble plot --------------------------------------------------------
fig <- plot_ly() |>
# background donut (100 % light-gray)
add_pie(
labels      = labels,
values      = values,
hole        = hole,
sort        = FALSE,
direction   = "clockwise",
marker      = list(colors = rep(background_color, steps),
line   = list(width = 0)),
textinfo    = "none",
hoverinfo   = "skip",
showlegend  = FALSE
) |>
# foreground donut (partial gradient)
add_pie(
labels      = labels,
values      = values,
hole        = hole,
sort        = FALSE,
direction   = "clockwise",
marker      = list(colors = fg_colors,
line   = list(width = 0)),
textinfo    = "none",
hoverinfo   = "skip",
showlegend  = FALSE
) |>
# Hide details
config(displayModeBar = FALSE, staticPlot = FALSE) |>
# centre annotation
layout(
paper_bgcolor="#2d2d2d",
plot_bgcolor="#2d2d2d",
annotations = list(list(
x = 0.5, y = 0.5,
text = paste(title, "\n", value/2.5, "%"),
showarrow = FALSE
)),
margin = list(l = 0, r = 0, b = 0, t = 0),
font = list(color = "white")
)
fig
}
# Maak de training load meters
ATL_gauge <- gauge_full("ATL", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$ATL * 2.5)
CTL_gauge <- gauge_full("CTL", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$CTL * 2.5)
ACWR_gauge <- gauge_full("ACWR", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$ACWR * 2.5)
# Functie voor huidige training status
get_training_status <- function(trimp_daily) {
# Extract today's row index
today_idx <- match(Sys.Date(), trimp_daily$date)
# Extract today's ATL, CTL, ACWR
ATL <- trimp_daily$ATL[today_idx]
CTL <- trimp_daily$CTL[today_idx]
ACWR <- trimp_daily$ACWR[today_idx]
# Define status based on conditions
status <- ifelse(ATL > 95 & ACWR > 85 & CTL < ATL, "Risk",
ifelse(ATL > 95 & CTL >= 65 & CTL <= 85 & ACWR > 75 & ACWR <= 85, "High",
ifelse(ATL > 80 & ATL <= 95 & CTL >= 60 & CTL <= 80 & ACWR > 60 & ACWR <= 75, "Optimal",
ifelse(ATL >= 55 & ATL <= 80 & CTL >= 55 & CTL <= 80 & ACWR >= 45 & ACWR <= 60, "Light",
ifelse(ATL < 55 & CTL < 55 & ACWR < 45, "Recovery",
ifelse(ATL < CTL & ACWR < 45, "Recovery",
# Catch-all fallback for any other cases
ifelse(ACWR < 45, "Recovery",
ifelse(ACWR <= 60, "Light",
ifelse(ACWR <= 75, "Optimal",
ifelse(ACWR <= 85, "High", "Risk"))))))))))
return(status)
}
# Huidige training status
status_today <- get_training_status(trimp_daily)
plot_training_load
ATL_gauge
CTL_gauge
ACWR_gauge
status_today
2*60*60
round(1 / (1 + exp(-5 * ((trimp_daily$ATL / trimp_daily$CTL) - 1))) * 100, 0)
###### FICTIEVE ACTIVITEIT
df_running_all <- add_row(df_running_all, date = as.Date(Sys.Date()), type = "Run",
time = 6*60*60,
hr = 100)
# Row-bind the dataframes
df_together <- rbind(df_running_all[, Reduce(intersect, list(colnames(df_running_all), colnames(df_cycling_all), colnames(df_swimming_all)))],
df_cycling_all[, Reduce(intersect, list(colnames(df_running_all), colnames(df_cycling_all), colnames(df_swimming_all)))],
df_swimming_all[, Reduce(intersect, list(colnames(df_running_all), colnames(df_cycling_all), colnames(df_swimming_all)))]) %>%
arrange(date) %>%
select(id, date, type, calories, distance, time, hr, hr_max, speed, speed_max)
# Define health values
personal_max_hr <- 188
personal_rest_hr <- 64
# Calculate TRIMP
df_together$duration <- df_together$time / 60
df_together$hr_percentage <- (df_together$hr - personal_rest_hr) / (personal_max_hr - personal_rest_hr)
df_together$TRIMP <- df_together$duration * df_together$hr_percentage * 0.64 * exp(1.92 * df_together$hr_percentage)
# Aggregate daily TRIMP scores
trimp_daily <- df_together %>% mutate(date = as.Date(date)) %>% group_by(date) %>% reframe(type = type, TRIMP = sum(TRIMP, na.rm = TRUE)) %>% arrange(date)
# Generate list of all days in the current year
all_dates <- data.frame(date = seq(min(trimp_daily$date), as.Date(paste0(substr(Sys.Date(), 1, 4), "-12-31")), by = "1 day"))
# Add TRIMP scores to the list
trimp_daily <- all_dates %>%
left_join(trimp_daily, by = "date") %>%
mutate(TRIMP = ifelse(is.na(TRIMP), 0, TRIMP))
# Initialize columns
trimp_daily$ATL <- NA
trimp_daily$CTL <- NA
# Initial values
trimp_daily$ATL[1] <- trimp_daily$TRIMP[1]
trimp_daily$CTL[1] <- trimp_daily$TRIMP[1]
# Define decay constants
kATL <- exp(-1/7)
kCTL <- exp(-1/42)
# Calculate moving averages
for (i in 2:nrow(trimp_daily)) {
trimp_daily$ATL[i] <- trimp_daily$TRIMP[i] + kATL * (trimp_daily$ATL[i-1] - trimp_daily$TRIMP[i])
trimp_daily$CTL[i] <- trimp_daily$TRIMP[i] + kCTL * (trimp_daily$CTL[i-1] - trimp_daily$TRIMP[i])
}
# Standardize scores
trimp_daily$ATL <- round(trimp_daily$ATL / max(trimp_daily$ATL, na.rm = TRUE) * 100, 0)
trimp_daily$CTL <- round(trimp_daily$CTL / max(trimp_daily$CTL, na.rm = TRUE) * 100, 0)
# Calculate Workload Ratio (ACWR) scores
trimp_daily$ACWR <- round(1 / (1 + exp(-5 * ((trimp_daily$ATL / trimp_daily$CTL) - 1))) * 100, 0)
# Round TRIMP values
trimp_daily$TRIMP <- round(trimp_daily$TRIMP, 0)
# Separate data for TRIMP bars
trimp_daily$type <- ifelse(trimp_daily$date > as.Date(Sys.Date()), "Run", trimp_daily$type)
trimp_bars <- trimp_daily %>% filter(!is.na(type)) %>% filter(date >= as.Date("2025-01-01") & date <= as.Date(Sys.Date()+42))
trimp_bars$type <- paste0(trimp_bars$type, " TRIMP")
if(min(trimp_bars$date, na.rm = TRUE) == "2025-01-01") {NULL} else {trimp_bars <- add_row(trimp_bars, date = as.Date("2025-01-01"), type = "Run TRIMP", TRIMP = 0, ATL = trimp_daily[which(trimp_daily$date == "2025-01-01"),]$ATL, CTL = trimp_daily[which(trimp_daily$date == "2025-01-01"),]$ATL, ACWR = trimp_daily[which(trimp_daily$date == "2025-01-01"),]$ACWR)}
trimp_bars <- trimp_bars %>% arrange(date)
# Define colors
colors <- c("Swim TRIMP" = "#3498db", "Ride TRIMP" = "#f39c12", "Run TRIMP" = "#54b98f")
# Recode factor type for color order
trimp_bars <- trimp_bars %>% mutate(type = factor(type, levels = c("Run TRIMP", "Ride TRIMP", "Swim TRIMP", NA)))
# Generate plot
plot_training_load <- trimp_daily %>%                     # your data frame
filter(date >= as.Date("2025-01-01") & date <= as.Date(Sys.Date()+42)) %>%
plot_ly(x = ~date) |>
# Trimp line  ── black, width 2 ≈ size 1 in ggplot
add_bars(data = trimp_bars,
x = ~date,
y = ~TRIMP,
color = ~type,
colors = colors,
name = ~type,
yaxis = "y2",
width = 86400000 * 1,
showlegend = TRUE,
customdata   = ~toupper(gsub(" TRIMP", "", type)),
hovertemplate = "<b>%{customdata}</b><br>%{x|%A}<br>%{x|%m/%d/%Y}<br>TRIMP: %{y}<extra></extra>") |>
# ATL line  ── black, width 2 ≈ size 1 in ggplot
add_lines(y = ~ATL/100,
name = "ATL (7-day)",
line = list(color = rgb(1, 1, 1, 0.50), width = 1, dash = "dot"),
hovertemplate = "<b>%{x|%A}<br>%{x|%m/%d/%Y}</b><br>ATL: %{y:.0%}<extra></extra>") |>
# CTL line  ── grey, width 2 ≈ size 1 in ggplot
add_lines(y = ~CTL/100,
name = "CTL (42-day)",
line = list(color = "#eb4034",  width = 4),
hovertemplate = "<b>%{x|%A}<br>%{x|%m/%d/%Y}</b><br>CTL: %{y:.0%}<extra></extra>") |>
# Hide details
config(displayModeBar = FALSE, staticPlot = FALSE) |>
# centre annotation
layout(
paper_bgcolor="#2d2d2d",
plot_bgcolor="#2d2d2d",
xaxis = list(zeroline = FALSE, fixedrange = TRUE, tickformat = "%b", tickvals = seq(as.Date("2025-01-01"), as.Date("2025-12-15"), by = "month"), ticktext = format(seq(as.Date("2025-01-01"), as.Date("2025-12-15"), by = "month"), "%b"), color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25),
yaxis  = list(zeroline = FALSE, fixedrange = TRUE, color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25, tickformat = ".0%"),
yaxis2 = list(zeroline = FALSE, fixedrange = TRUE, color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25, overlaying = "y", side = "right", range = c(0, 2 * max(trimp_daily$TRIMP, na.rm = TRUE))),
barmode = 'overlay',
legend = list(orientation = "v", x = 0.05, y = 1, font = list(color = "white")),
margin = list(l = 0, r = 30, t = 0, b = 0)
)
# Functie om training load meters te maken
gauge_full <- function(title,
value,
steps = 250,
palette = c("lightgreen", "yellow", "red", "darkred"),
hole   = 0.6,
font_size = 50,
background_color = rgb(0, 0, 0, 0.10)) {
# ---- basic sanity checks --------------------------------------------------
if (!is.numeric(value) || value < 0 || value > steps) {
stop("`value` must be between 0 and `steps` (", steps, ").", call. = FALSE)
}
# ---- build colour vectors -------------------------------------------------
full_palette  <- colorRampPalette(palette)(steps)        # complete gradient
fill_colors   <- full_palette[seq_len(value)]            # part to show
transparent   <- "rgba(0,0,0,0)"                         # invisible slices
fg_colors     <- c(fill_colors, rep(transparent, steps - value))
# one unit per slice so ∑ = 360°
values  <- rep(1, steps)
labels  <- paste0("slice_", seq_len(steps))              # invisible
# ---- assemble plot --------------------------------------------------------
fig <- plot_ly() |>
# background donut (100 % light-gray)
add_pie(
labels      = labels,
values      = values,
hole        = hole,
sort        = FALSE,
direction   = "clockwise",
marker      = list(colors = rep(background_color, steps),
line   = list(width = 0)),
textinfo    = "none",
hoverinfo   = "skip",
showlegend  = FALSE
) |>
# foreground donut (partial gradient)
add_pie(
labels      = labels,
values      = values,
hole        = hole,
sort        = FALSE,
direction   = "clockwise",
marker      = list(colors = fg_colors,
line   = list(width = 0)),
textinfo    = "none",
hoverinfo   = "skip",
showlegend  = FALSE
) |>
# Hide details
config(displayModeBar = FALSE, staticPlot = FALSE) |>
# centre annotation
layout(
paper_bgcolor="#2d2d2d",
plot_bgcolor="#2d2d2d",
annotations = list(list(
x = 0.5, y = 0.5,
text = paste(title, "\n", value/2.5, "%"),
showarrow = FALSE
)),
margin = list(l = 0, r = 0, b = 0, t = 0),
font = list(color = "white")
)
fig
}
# Maak de training load meters
ATL_gauge <- gauge_full("ATL", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$ATL * 2.5)
CTL_gauge <- gauge_full("CTL", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$CTL * 2.5)
ACWR_gauge <- gauge_full("ACWR", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$ACWR * 2.5)
# Functie voor huidige training status
get_training_status <- function(trimp_daily) {
# Extract today's row index
today_idx <- match(Sys.Date(), trimp_daily$date)
# Extract today's ATL, CTL, ACWR
ATL <- trimp_daily$ATL[today_idx]
CTL <- trimp_daily$CTL[today_idx]
ACWR <- trimp_daily$ACWR[today_idx]
# Define status based on conditions
status <- ifelse(ATL > 95 & ACWR > 85 & CTL < ATL, "Risk",
ifelse(ATL > 95 & CTL >= 65 & CTL <= 85 & ACWR > 75 & ACWR <= 85, "High",
ifelse(ATL > 80 & ATL <= 95 & CTL >= 60 & CTL <= 80 & ACWR > 60 & ACWR <= 75, "Optimal",
ifelse(ATL >= 55 & ATL <= 80 & CTL >= 55 & CTL <= 80 & ACWR >= 45 & ACWR <= 60, "Light",
ifelse(ATL < 55 & CTL < 55 & ACWR < 45, "Recovery",
ifelse(ATL < CTL & ACWR < 45, "Recovery",
# Catch-all fallback for any other cases
ifelse(ACWR < 45, "Recovery",
ifelse(ACWR <= 60, "Light",
ifelse(ACWR <= 75, "Optimal",
ifelse(ACWR <= 85, "High", "Risk"))))))))))
return(status)
}
# Huidige training status
status_today <- get_training_status(trimp_daily)
plot_training_load
###### FICTIEVE ACTIVITEIT
df_running_all <- add_row(df_running_all, date = as.Date(Sys.Date()), type = "Run",
time = 153*60*60,
hr = 200)
# Row-bind the dataframes
df_together <- rbind(df_running_all[, Reduce(intersect, list(colnames(df_running_all), colnames(df_cycling_all), colnames(df_swimming_all)))],
df_cycling_all[, Reduce(intersect, list(colnames(df_running_all), colnames(df_cycling_all), colnames(df_swimming_all)))],
df_swimming_all[, Reduce(intersect, list(colnames(df_running_all), colnames(df_cycling_all), colnames(df_swimming_all)))]) %>%
arrange(date) %>%
select(id, date, type, calories, distance, time, hr, hr_max, speed, speed_max)
# Define health values
personal_max_hr <- 188
personal_rest_hr <- 64
# Calculate TRIMP
df_together$duration <- df_together$time / 60
df_together$hr_percentage <- (df_together$hr - personal_rest_hr) / (personal_max_hr - personal_rest_hr)
df_together$TRIMP <- df_together$duration * df_together$hr_percentage * 0.64 * exp(1.92 * df_together$hr_percentage)
# Aggregate daily TRIMP scores
trimp_daily <- df_together %>% mutate(date = as.Date(date)) %>% group_by(date) %>% reframe(type = type, TRIMP = sum(TRIMP, na.rm = TRUE)) %>% arrange(date)
# Generate list of all days in the current year
all_dates <- data.frame(date = seq(min(trimp_daily$date), as.Date(paste0(substr(Sys.Date(), 1, 4), "-12-31")), by = "1 day"))
# Add TRIMP scores to the list
trimp_daily <- all_dates %>%
left_join(trimp_daily, by = "date") %>%
mutate(TRIMP = ifelse(is.na(TRIMP), 0, TRIMP))
# Initialize columns
trimp_daily$ATL <- NA
trimp_daily$CTL <- NA
# Initial values
trimp_daily$ATL[1] <- trimp_daily$TRIMP[1]
trimp_daily$CTL[1] <- trimp_daily$TRIMP[1]
# Define decay constants
kATL <- exp(-1/7)
kCTL <- exp(-1/42)
# Calculate moving averages
for (i in 2:nrow(trimp_daily)) {
trimp_daily$ATL[i] <- trimp_daily$TRIMP[i] + kATL * (trimp_daily$ATL[i-1] - trimp_daily$TRIMP[i])
trimp_daily$CTL[i] <- trimp_daily$TRIMP[i] + kCTL * (trimp_daily$CTL[i-1] - trimp_daily$TRIMP[i])
}
# Standardize scores
trimp_daily$ATL <- round(trimp_daily$ATL / max(trimp_daily$ATL, na.rm = TRUE) * 100, 0)
trimp_daily$CTL <- round(trimp_daily$CTL / max(trimp_daily$CTL, na.rm = TRUE) * 100, 0)
# Calculate Workload Ratio (ACWR) scores
trimp_daily$ACWR <- round(1 / (1 + exp(-5 * ((trimp_daily$ATL / trimp_daily$CTL) - 1))) * 100, 0)
# Round TRIMP values
trimp_daily$TRIMP <- round(trimp_daily$TRIMP, 0)
# Separate data for TRIMP bars
trimp_daily$type <- ifelse(trimp_daily$date > as.Date(Sys.Date()), "Run", trimp_daily$type)
trimp_bars <- trimp_daily %>% filter(!is.na(type)) %>% filter(date >= as.Date("2025-01-01") & date <= as.Date(Sys.Date()+42))
trimp_bars$type <- paste0(trimp_bars$type, " TRIMP")
if(min(trimp_bars$date, na.rm = TRUE) == "2025-01-01") {NULL} else {trimp_bars <- add_row(trimp_bars, date = as.Date("2025-01-01"), type = "Run TRIMP", TRIMP = 0, ATL = trimp_daily[which(trimp_daily$date == "2025-01-01"),]$ATL, CTL = trimp_daily[which(trimp_daily$date == "2025-01-01"),]$ATL, ACWR = trimp_daily[which(trimp_daily$date == "2025-01-01"),]$ACWR)}
trimp_bars <- trimp_bars %>% arrange(date)
# Define colors
colors <- c("Swim TRIMP" = "#3498db", "Ride TRIMP" = "#f39c12", "Run TRIMP" = "#54b98f")
# Recode factor type for color order
trimp_bars <- trimp_bars %>% mutate(type = factor(type, levels = c("Run TRIMP", "Ride TRIMP", "Swim TRIMP", NA)))
# Generate plot
plot_training_load <- trimp_daily %>%                     # your data frame
filter(date >= as.Date("2025-01-01") & date <= as.Date(Sys.Date()+42)) %>%
plot_ly(x = ~date) |>
# Trimp line  ── black, width 2 ≈ size 1 in ggplot
add_bars(data = trimp_bars,
x = ~date,
y = ~TRIMP,
color = ~type,
colors = colors,
name = ~type,
yaxis = "y2",
width = 86400000 * 1,
showlegend = TRUE,
customdata   = ~toupper(gsub(" TRIMP", "", type)),
hovertemplate = "<b>%{customdata}</b><br>%{x|%A}<br>%{x|%m/%d/%Y}<br>TRIMP: %{y}<extra></extra>") |>
# ATL line  ── black, width 2 ≈ size 1 in ggplot
add_lines(y = ~ATL/100,
name = "ATL (7-day)",
line = list(color = rgb(1, 1, 1, 0.50), width = 1, dash = "dot"),
hovertemplate = "<b>%{x|%A}<br>%{x|%m/%d/%Y}</b><br>ATL: %{y:.0%}<extra></extra>") |>
# CTL line  ── grey, width 2 ≈ size 1 in ggplot
add_lines(y = ~CTL/100,
name = "CTL (42-day)",
line = list(color = "#eb4034",  width = 4),
hovertemplate = "<b>%{x|%A}<br>%{x|%m/%d/%Y}</b><br>CTL: %{y:.0%}<extra></extra>") |>
# Hide details
config(displayModeBar = FALSE, staticPlot = FALSE) |>
# centre annotation
layout(
paper_bgcolor="#2d2d2d",
plot_bgcolor="#2d2d2d",
xaxis = list(zeroline = FALSE, fixedrange = TRUE, tickformat = "%b", tickvals = seq(as.Date("2025-01-01"), as.Date("2025-12-15"), by = "month"), ticktext = format(seq(as.Date("2025-01-01"), as.Date("2025-12-15"), by = "month"), "%b"), color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25),
yaxis  = list(zeroline = FALSE, fixedrange = TRUE, color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25, tickformat = ".0%"),
yaxis2 = list(zeroline = FALSE, fixedrange = TRUE, color = "white", title = NA, gridcolor = "#333", gridwidth = 0.25, overlaying = "y", side = "right", range = c(0, 2 * max(trimp_daily$TRIMP, na.rm = TRUE))),
barmode = 'overlay',
legend = list(orientation = "v", x = 0.05, y = 1, font = list(color = "white")),
margin = list(l = 0, r = 30, t = 0, b = 0)
)
# Functie om training load meters te maken
gauge_full <- function(title,
value,
steps = 250,
palette = c("lightgreen", "yellow", "red", "darkred"),
hole   = 0.6,
font_size = 50,
background_color = rgb(0, 0, 0, 0.10)) {
# ---- basic sanity checks --------------------------------------------------
if (!is.numeric(value) || value < 0 || value > steps) {
stop("`value` must be between 0 and `steps` (", steps, ").", call. = FALSE)
}
# ---- build colour vectors -------------------------------------------------
full_palette  <- colorRampPalette(palette)(steps)        # complete gradient
fill_colors   <- full_palette[seq_len(value)]            # part to show
transparent   <- "rgba(0,0,0,0)"                         # invisible slices
fg_colors     <- c(fill_colors, rep(transparent, steps - value))
# one unit per slice so ∑ = 360°
values  <- rep(1, steps)
labels  <- paste0("slice_", seq_len(steps))              # invisible
# ---- assemble plot --------------------------------------------------------
fig <- plot_ly() |>
# background donut (100 % light-gray)
add_pie(
labels      = labels,
values      = values,
hole        = hole,
sort        = FALSE,
direction   = "clockwise",
marker      = list(colors = rep(background_color, steps),
line   = list(width = 0)),
textinfo    = "none",
hoverinfo   = "skip",
showlegend  = FALSE
) |>
# foreground donut (partial gradient)
add_pie(
labels      = labels,
values      = values,
hole        = hole,
sort        = FALSE,
direction   = "clockwise",
marker      = list(colors = fg_colors,
line   = list(width = 0)),
textinfo    = "none",
hoverinfo   = "skip",
showlegend  = FALSE
) |>
# Hide details
config(displayModeBar = FALSE, staticPlot = FALSE) |>
# centre annotation
layout(
paper_bgcolor="#2d2d2d",
plot_bgcolor="#2d2d2d",
annotations = list(list(
x = 0.5, y = 0.5,
text = paste(title, "\n", value/2.5, "%"),
showarrow = FALSE
)),
margin = list(l = 0, r = 0, b = 0, t = 0),
font = list(color = "white")
)
fig
}
# Maak de training load meters
ATL_gauge <- gauge_full("ATL", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$ATL * 2.5)
CTL_gauge <- gauge_full("CTL", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$CTL * 2.5)
ACWR_gauge <- gauge_full("ACWR", trimp_daily[match(Sys.Date(), trimp_daily$date), ]$ACWR * 2.5)
# Functie voor huidige training status
get_training_status <- function(trimp_daily) {
# Extract today's row index
today_idx <- match(Sys.Date(), trimp_daily$date)
# Extract today's ATL, CTL, ACWR
ATL <- trimp_daily$ATL[today_idx]
CTL <- trimp_daily$CTL[today_idx]
ACWR <- trimp_daily$ACWR[today_idx]
# Define status based on conditions
status <- ifelse(ATL > 95 & ACWR > 85 & CTL < ATL, "Risk",
ifelse(ATL > 95 & CTL >= 65 & CTL <= 85 & ACWR > 75 & ACWR <= 85, "High",
ifelse(ATL > 80 & ATL <= 95 & CTL >= 60 & CTL <= 80 & ACWR > 60 & ACWR <= 75, "Optimal",
ifelse(ATL >= 55 & ATL <= 80 & CTL >= 55 & CTL <= 80 & ACWR >= 45 & ACWR <= 60, "Light",
ifelse(ATL < 55 & CTL < 55 & ACWR < 45, "Recovery",
ifelse(ATL < CTL & ACWR < 45, "Recovery",
# Catch-all fallback for any other cases
ifelse(ACWR < 45, "Recovery",
ifelse(ACWR <= 60, "Light",
ifelse(ACWR <= 75, "Optimal",
ifelse(ACWR <= 85, "High", "Risk"))))))))))
return(status)
}
# Huidige training status
status_today <- get_training_status(trimp_daily)
plot_training_load
ATL_gauge
CTL_gauge
ACWR_gauge
status_today
